import { TestCase } from '../SingleEffect_test';
import {
    GameState, getRNGContext,
} from '../../Game/Game';
import * as T from '../../test';
import {
    GlobalStateEntityCode,
} from '../../Entity/Header';
import { IAsInterceptor } from '../../Entity/Entities/AsInterceptor';
import { NewEntityCode } from '../../Entity/EntityCode';
import {
    TargetType, IEffectPackFilter,
} from './../Header';
import SetIntercept, { ISetInterceptorEffectPack } from './SetIntercept';
import RemoveIntercept from './RemoveIntercept';
import Affix,
    { IAffixMutator, AffixMutatorPlacment } from './../Mutators/Affix';

let cases: Array<TestCase> = [];

let fakeMutator = 'some-mutator';
let fakeEffect = 'some-effect';

(() => {
    // We need to compute the EntityCode ahead of time.
    //
    // We rely on the default, static seed to ensure consistency
    // of results between GameState instances for RNG access.
    let state = new GameState(T.GetDefaultPlayers());
    let identity;
    getRNGContext(state, (rng) => {
        identity = NewEntityCode(rng);
    });
    if (identity === undefined) throw Error('failed to fetch EntityCode');

    let interceptor = {
        Identity: identity,
        IsInterceptor: true,
        Filter: {},
        Mutator: {
            Mutator: fakeMutator,
        },
    } as IAsInterceptor;
    let expectedInterceptors = [interceptor];

    cases.push([
        new GameState(T.GetDefaultPlayers()),
        {
            Source: T.PlayerOneEntityCode,
            Targets: [GlobalStateEntityCode],
            TargetType: TargetType.Global,
            Effect: SetIntercept.Self,

            Filter: interceptor.Filter,
            Mutator: interceptor.Mutator,
        } as ISetInterceptorEffectPack,
        'SetInterceptor registers interceptor',
        {
            StackHeight: 0,
            interceptsHas: expectedInterceptors,
        },
    ]);
})();

(() => {
    // We need to compute the EntityCode ahead of time.
    //
    // We rely on the default, static seed to ensure consistency
    // of results between GameState instances for RNG access.
    let state = new GameState(T.GetDefaultPlayers());
    let interceptorIdentity;
    let expiryIdentity;
    getRNGContext(state, (rng) => {
        interceptorIdentity = NewEntityCode(rng);
        expiryIdentity = NewEntityCode(rng);
    });
    if (interceptorIdentity === undefined) throw Error('failed to fetch EntityCode');
    if (expiryIdentity === undefined) throw Error('failed to fetch EntityCode');

    let interceptor = {
        Identity: interceptorIdentity,
        IsInterceptor: true,
        Filter: {},
        Mutator: {
            Mutator: fakeMutator,
        },
    } as IAsInterceptor;

    let expiryFilter = {
        Effect: fakeEffect,
    } as IEffectPackFilter;
    let expiry = {
        Identity: expiryIdentity,
        IsInterceptor: true,
        Filter: expiryFilter,
        Mutator: {
            Mutator: Affix.Self,
            Others: [
                // Generated by manually validating the output
                // from the test. This should never change unless
                // functional changes imply it.
                {
                    Source: interceptorIdentity,
                    Targets: [
                        interceptorIdentity,
                    ],
                    TargetType: TargetType.Interceptor,
                    Effect: RemoveIntercept.Self,
                  },
                  {
                    Source: expiryIdentity,
                    Targets: [
                        expiryIdentity,
                    ],
                    TargetType: TargetType.Interceptor,
                    Effect: RemoveIntercept.Self,
                  },
            ],
            Placement: AffixMutatorPlacment.After,
        } as IAffixMutator,
    } as IAsInterceptor;
    let expectedInterceptors = [interceptor, expiry];

    cases.push([
        new GameState(T.GetDefaultPlayers()),
        {
            Source: T.PlayerOneEntityCode,
            Targets: [GlobalStateEntityCode],
            TargetType: TargetType.Global,
            Effect: SetIntercept.Self,

            Filter: interceptor.Filter,
            Mutator: interceptor.Mutator,
            Expiry: expiryFilter,
        } as ISetInterceptorEffectPack,
        'SetInterceptor registers interceptor with desired expiry',
        {
            StackHeight: 0,
            interceptsHas: expectedInterceptors,
        },
    ]);
})();

export default cases;
